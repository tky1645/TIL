## 抽象化レイヤー 
問題を小さな問題に分割したもの｜その階層構造を抽象化レイヤーと定義する

抽象化レイヤーの各問題を解決するためにコードも分割されていく。
一対一対応とは限らない。

## コードの良い分割方法とはなんだろうか

クラスの分割の目安として、「コード品質の柱で達成したかった目的を達成できているか？」を使うと良い  
例えば、コードがモジュール化されていて交換可能か？再利用できるか？

（達成できているか、は主観的なのでこれも絶対じゃないなあ)

再利用するのが自分だろうと他人だろうと契約による設計をすべき

### では契約とはどのように結ばせるか

ドキュメントやコメントへの記載に頼らなければならない場面もある（注意事項や悪いコードへの依存で特殊な挙動をする場合など）  
しかしコメントやドキュメントは契約としての信頼性は低い。

それらよりファクトリー関数などコードでの契約を使うべき  
契約の目標は、契約違反だとコンパイルできないようにする

それができなければ契約やアサーションでエラーを投げる

## エラー

回復可能なエラーと不可能なエラーがある  
不可能なエラーとはベタ書き文字列が不正だとかあるべき画像リソースが無い、など。

エラー処理は、システムの堅牢性とエラーの気付きやすさのトレードオフになりやすい。

基本的には非検査例外を投げる後者の対応が推奨される。しかしプロダクションコードで頻繁にクラッシュするのは避けたい。

なので下位レイヤーではエラーを通知し、上位レイヤーがログ記録して握りつぶすなどの判断をするべき。

検査例外（Checked Exception）は、コンパイラが「このコードを正しく動作させるために、発生する可能性のあるエラーをどう処理するか明示する必要がある」と判断する例外です

- 検査例外にしておくとコードの契約で例外の対応を強制できる。
- そうでなければコメントに投げる種類のエラーを記載しておく。

null安全を採用している言語ならnullを返すとエラー処理を強制できる。  
オプショナル型でも似たようなことができる。ただしエラーの理由を通知できない

それを解決するためにResult型を使うこともあり。言語によっては自作で作る　97